#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     button,         sensorTouch)
#pragma config(Motor,  motorA,          right,         tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          left,          tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Create a 2d array of size 7 x 7
int width = 5;
int height = 5;
int map[5][5];

int boxSize = 8;

int max = 20;
int NodeIndex = 0;
int checkedNodes[12];
int visitedNodes[12];
int visitedIndex = 0;

bool clockwise = false;

int currentX = 1;
int currentY = 1;
string currentDirection = "North";

int currentNode = currentY * width + currentX;

string neighborDirection;


void goStraight() {
	motor(left) = 30;
	motor(right) = 30;
	int counter = 22;
	// Robot moves 1 grid space
	// But the grid spaces may not be perfectly square so need to account for error
	// Make robot stop if it is too close to the wall
	for (int i = 0; i < counter; i++) {
		if (SensorValue[sonar] < 15) {
			motor(left) = 0;
			motor(right) = 0;
		}
		else {
			wait1Msec(100);
		}
	}
	motor(left) = 0;
	motor(right) = 0;
	wait1Msec(300);
}

void turnRight() {
	motor(left) = 20;
	motor(right) = -20;
	//wait1Msec(1000);
	wait1Msec(1027);
	motor(left) = 0;
	motor(right) = 0;
	wait1Msec(300);
	nxtDisplayTextLine(0, "%2.2f", SensorValue[sonar]);
}

void turnLeft() {
	motor(left) = -20;
	motor(right) = 20;
	//wait1Msec(1000);
	wait1Msec(1027);
	motor(left) = 0;
	motor(right) = 0;
	wait1Msec(300);
	nxtDisplayTextLine(0, "%2.2f", SensorValue[sonar]);
}

void turnToDirection(string targetDirection) {
	if (clockwise) {
		if (currentDirection == "North") {
			if (targetDirection == "East") {
				turnRight();
			}
			else if (targetDirection == "South") {
				turnRight();
				turnRight();
			}
			else if (targetDirection == "West") {
				turnLeft();
			}
		}
		else if (currentDirection == "East") {
			if (targetDirection == "South") {
				turnRight();
			}
			else if (targetDirection == "West") {
				turnRight();
				turnRight();
			}
			else if (targetDirection == "North") {
				turnLeft();
			}
		}
		else if (currentDirection == "South") {
			if (targetDirection == "West") {
				turnRight();
			}
			else if (targetDirection == "North") {
				turnRight();
				turnRight();
			}
			else if (targetDirection == "East") {
				turnLeft();
			}
		}
		else {
			if (targetDirection == "North") {
				turnRight();
			}
			else if (targetDirection == "East") {
				turnRight();
				turnRight();
			}
			else if (targetDirection == "South") {
				turnLeft();
			}
		}
	}
	else {
		if (currentDirection == "North") {
			if (targetDirection == "East") {
				turnRight();
			}
			else if (targetDirection == "South") {
				turnLeft();
				turnLeft();
			}
			else if (targetDirection == "West") {
				turnLeft();
			}
		}
		else if (currentDirection == "East") {
			if (targetDirection == "South") {
				turnRight();
			}
			else if (targetDirection == "West") {
				turnLeft();
				turnLeft();
			}
			else if (targetDirection == "North") {
				turnLeft();
			}
		}else if (currentDirection == "South") {
			if (targetDirection == "West") {
				turnRight();
			}
			else if (targetDirection == "North") {
				turnLeft();
				turnLeft();
			}
			else if (targetDirection == "East") {
				turnLeft();
			}
		}
		else {
			if (targetDirection == "North") {
				turnRight();
			}
			else if (targetDirection == "East") {
				turnRight();
				turnRight();
			}
			else if (targetDirection == "South") {
				turnLeft();
			}
		}
	}

	// Update currentDirection
	currentDirection = targetDirection;
}


void checkSurroundings(int x, int y) {
	int northX = x;
	int	northY = y + 1;
	int eastX = x + 1;
	int eastY = y;
	int southX = x;
	int southY = y - 1;
	int westX = x - 1;
	int westY = y;
	// Check surrondings and if wall is less than maxDistance away put a 1 at that position
	if (clockwise) {
		if (currentDirection == "North") {
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			currentDirection = "West";
		}
		else if (currentDirection == "East") {
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			currentDirection = "North";
		}
		else if (currentDirection == "South") {
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			currentDirection = "East";
		}
		// West
		else {
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			turnRight();
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			currentDirection = "South";
		}
	}
	//
	else {
		if (currentDirection == "North") {
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			currentDirection = "East";
		}
		else if (currentDirection == "East") {
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			currentDirection = "South";
		}
		else if (currentDirection == "South") {
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			currentDirection = "West";
		}
		// West
		else {
			if (SensorValue[sonar] < max) {
				map[westX][westY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[southX][southY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[eastX][eastY] = 1;
			}
			turnLeft();
			if (SensorValue[sonar] < max) {
				map[northX][northY] = 1;
			}
			currentDirection = "North";
		}
	}
	clockwise = !clockwise;
}

bool checked(int Node) {
	for (int i = 0; i < NodeIndex; i++) {
		if (checkedNodes[i] == Node) {
			return true;
		}
	}
	// If not in checkedNode
	return false;
}

bool checkedVisited(int Node) {
	for (int i = 0; i < visitedIndex; i++) {
		if (visitedNodes[i] == Node) {
			return true;
		}
	}
	return false;
}

int numOfObstacles() {
	int counter = 0;
	for (int i = 0; i < width; i++) {
		for (int j = 0; j < height; j++) {
			if (map[i][j] == 1) {
				counter++;
			}
		}
	}
	return counter;
}

void drawSurroundings(int x, int y) {
	int northX = x;
	int	northY = y + 1;
	int eastX = x + 1;
	int eastY = y;
	int southX = x;
	int southY = y - 1;
	int westX = x - 1;
	int westY = y;
	int half = boxSize/2;
	int centerX = boxSize*x;
	int centerY = boxSize*y;
	if (map[northX][northY] == 1) {
		drawLine(centerX - half,centerY + half, centerX + half, centerY + half);
	}
	if (map[eastX][eastY] == 1) {
		drawLine(centerX + half, centerY + half, centerX + half, centerY - half);
	}
	if (map[southX][southY] == 1) {
		drawLine(centerX - half, centerY - half, centerX + half, centerY - half);
	}
	if (map[westX][westY] == 1) {
		drawLine(centerX - half, centerY + half, centerX - half, centerY - half);
	}
}

void findNeighborDirection(int x, int y) {
	int northX = x;
	int	northY = y + 1;
	int eastX = x + 1;
	int eastY = y;
	int southX = x;
	int southY = y - 1;
	int westX = x - 1;
	int westY = y;
	if (map[northX][northY] == 0) {
		// Convert coordinates to node index
		int node = northY * width + northX;
		// If there is a neighbor that isn't a wall check if it is in checkedNodes
		bool checked = false;
		for (int i = 0; i < NodeIndex; i++) {
			if (checkedNodes[i] == node) {
				checked = true;
				break;
			}
		}
		if (!checked) {
			neighborDirection = "North";
			return;
		}
	}
	if (map[eastX][eastY] == 0) {
		int node = eastY * width + eastX;
		// If there is a neighbor that isn't a wall check if it is in checkedNodes
		bool checked = false;
		for (int i = 0; i < NodeIndex; i++) {
			if (checkedNodes[i] == node) {
				checked = true;
				break;
			}
		}
		if (!checked) {
			neighborDirection = "East";
			return;
		}
	}
	if (map[southX][southY] == 0) {
		int node = southY * width + southX;
		// If there is a neighbor that isn't a wall check if it is in checkedNodes
		bool checked = false;
		for (int i = 0; i < NodeIndex; i++) {
			if (checkedNodes[i] == node) {
				checked = true;
				break;
			}
		}
		if (!checked) {
			neighborDirection = "South";
			return;
		}
	}
	if (map[westX][westY] == 0) {
		int node = westY * width + westX;
		// If there is a neighbor that isn't a wall check if it is in checkedNodes
		bool checked = false;
		for (int i = 0; i < NodeIndex; i++) {
			if (checkedNodes[i] == node) {
				checked = true;
				break;
			}
		}
		if (!checked) {
			neighborDirection = "West";
			return;
		}
	}
	// -1 for no unchecked neighbor
	neighborDirection = "None";
}

void updatePosition(string targetDirection) {
	if (targetDirection == "North") {
		currentY =currentY + 1;
	}
	else if (targetDirection == "East") {
		currentX = currentX + 1;
	}
	else if (targetDirection == "South") {
		currentY = currentY - 1;
	}
	else if (targetDirection == "West") {
		currentX = currentX - 1;
	}
	currentNode = currentY * width + currentX;
}

int uncheckedNeighbor(int x, int y) {
	int northX = x;
	int	northY = y + 1;
	int eastX = x + 1;
	int eastY = y;
	int southX = x;
	int southY = y - 1;
	int westX = x - 1;
	int westY = y;
	if (map[northX][northY] == 0) {
		int node = northY * width + northX;
		if (!checked(node)) {
			return node;
		}
	}
	if (map[eastX][eastY] == 0) {
		int node = eastY * width + eastX;
		if (!checked(node)) {
			return node;
		}
	}
	if (map[southX][southY] == 0) {
		int node = southY * width + southX;
		if (!checked(node)) {
			return node;
		}
	}
	if (map[westX][westY] == 0) {
		int node = westY * width + westX;
		if (!checked(node)) {
			return node;
		}
	}
	return -1;
}

int findUncheckedNode() {
	for (int i = 0; i < width; i++) {
		for (int j = 0; j < height; j++) {
			int node = j * width + i;
			// find a checked node that has a neighbor that is not checked
			if (checked(node)) {
				int unchecked = uncheckedNeighbor(i, j);
				// check if this visited node has a unchecked neighbor
				if (unchecked == -1) {
					// No such neighbor
				}
				else {
					return unchecked;
				}
			}
		}
	}
	return -1;
}

int calculateDistance(int x, int y, int targetX, int targetY) {
	return sqrt(abs(x-targetX)^2 + abs(y-targetY)^2);
}

int getClosestNeighbor(int x, int y, int targetX, int targetY) {
	int northX = x;
	int	northY = y + 1;
	int eastX = x + 1;
	int eastY = y;
	int southX = x;
	int southY = y - 1;
	int westX = x - 1;
	int westY = y;

	int closest = -1;
	int returnNode = -1;
	if (map[northX][northY] == 0) {
		int node = northY * width + northX;
		if (northY == targetY && northX == targetX) {
				return node;
		}
		if (checked(node) && !checkedVisited(node)) {
			if (closest == -1) {
				closest = calculateDistance(northX, northY, targetX, targetY);
				returnNode = node;
			}
			else {
				int distance = calculateDistance(northX, northY, targetX, targetY);
				if (distance < closest) {
					closest = distance;
					returnNode = node;
				}
			}
		}
	}
	if (map[eastX][eastY] == 0) {
		int node = eastY * width + eastX;
		if (eastY == targetY && eastX == targetX) {
			return node;
		}
		if (checked(node) && !checkedVisited(node)) {
				if (closest == -1) {
				closest = calculateDistance(eastX, eastY, targetX, targetY);
				returnNode = node;
			}
			else {
				int distance = calculateDistance(eastX, eastY, targetX, targetY);
				if (distance < closest) {
					closest = distance;
					returnNode = node;
				}
			}
		}
	}
	if (map[southX][southY] == 0) {
		int node = southY * width + southX;
		if (southY == targetY && southX == targetX) {
			return node;
		}
		if (checked(node) && !checkedVisited(node)) {
			if (closest == -1) {
				closest = calculateDistance(southX, southY, targetX, targetY);
				returnNode = node;
			}
			else {
				int distance = calculateDistance(southX, southY, targetX, targetY);
				if (distance < closest) {
					closest = distance;
					returnNode = node;
				}
			}
		}
	}
	if (map[westX][westY] == 0) {
		int node = westY * width + westX;
		if (westY == targetY && westX == targetX) {
			return node;
		}
		if (checked(node) && !checkedVisited(node)) {
			if (closest == -1) {
				closest = calculateDistance(westX, westY, targetX, targetY);
				returnNode = node;
			}
			else {
				int distance = calculateDistance(westX, westY, targetX, targetY);
				if (distance < closest) {
					closest = distance;
					returnNode = node;
				}
			}
		}
	}
	return returnNode;
}


void moveToTargetNode(int targetX, int targetY) {
	// empty array by setting array size/index to 0;
	visitedIndex = 0;

	// Add the current node to the visited Nodes
	visitedNodes[visitedIndex] = currentY * width + currentX;
	visitedIndex += 1;
	while(!(currentX == targetX && currentY == targetY)) {
		// Check current node's neighbors and calculate the distance from the visited neighbor nodes to target
		int neighborNode = getClosestNeighbor(currentX, currentY, targetX, targetY);
		visitedNodes[visitedIndex] = neighborNode;
		visitedIndex += 1;
		// target is to the left
		int neighborY = (int)(neighborNode / width);
		int neighborX = neighborNode - (neighborY * width);
		// Move North or South
		if (currentX == neighborX) {
			// Move North
			if (currentY < neighborY) {
				string direction = "North";
				turnToDirection(direction);
				updatePosition(direction);
				goStraight();
			}
			// Move South
			else {
				string direction = "South";
				turnToDirection(direction);
				updatePosition(direction);
				goStraight();
			}
		}
		// Move East or West
		else if (currentY == neighborY) {
			// Move East
			if (currentX < neighborX) {
				string direction = "East";
				turnToDirection(direction);
				updatePosition(direction);
				goStraight();
			}
			// Move West
			else {
				string direction = "West";
				turnToDirection(direction);
				updatePosition(direction);
				goStraight();
			}
		}
	}
}

task main()
{
	// Fill in the outer perimeter with 1's to create the enclosed map
	for (int i = 0; i < width; i++) {
		map[i][0] = 1;
		map[i][height-1] = 1;
	}
	// Fill top and bottom row
	for (int i = 0; i < height; i++) {
		map[0][i] = 1;
		int v = width - 1;
		map[v][i] = 1;
	}

	// Continue until all nodes are checked
	// checkedNodes + obstacles < total nodes
	while (NodeIndex + numOfObstacles() < width*height) {
		if (!checked(currentNode)) {
			// Check surroundings and mark obstacles
			checkSurroundings(currentX, currentY);
			// Add current position to checkedNodes
			// index = (row * width) + column
			// row = currentY and column = currentX
			checkedNodes[NodeIndex] = currentNode;
			NodeIndex += 1;
			// Draw the obstacles found
			drawSurroundings(currentX, currentY);

			// Find unchecked neighbor Node
			findNeighborDirection(currentX, currentY);
			if (neighborDirection == "None") {
				// Find nearest uncheckedNode
				int targetNode = findUncheckedNode();

				// If there are no more unvisited nodes stop program
				if (targetNode == -1) {
					break;
				}
				// Calculate the path to target node
				int targetY = (int)(targetNode / width);
				int targetX = targetNode - (targetY * width);

				moveToTargetNode(targetX, targetY);

			}
			else{
				// Move to that direction
				turnToDirection(neighborDirection);
				goStraight();
				updatePosition(neighborDirection);
			}
		}
	}




	while(SensorValue[button] == 0) {

	}
}
